\mainpage General Information
\tableofcontents
 \section intro Introduction
This is a C++ header only library devoted to computations of symmetric polynomials on multiple variables with relations. You can find the GitHub repository 
<a href="https://github.com/NickG-Math/Symmetric_Polynomials">here</a>.


\section req Requirements
 * A C++17 compiler, such as the LLVM based Clang or Visual C++ (MSVC).
 
\section install Installation

* To install simply clone/download the <a href="https://github.com/NickG-Math/Symmetric_Polynomials">repository</a> and include it in your path. 

* See the page \ref use for a tutorial on using the library. For a brief explanation on the math behind it, see \ref math.

* As for compiler support, the latest version of the code is always tested with the latest stable versions of Clang (Linux) and MSVC (Windows). Remember to use the option ```-std=c++17```. 

\section doc Documentation

This documentation is organized in pages as follows:
 
* The pages \ref index, \ref math, \ref use, explain how the program works.

* The pages <a href="namespaces.html">Namespaces</a>, <a href="annotated.html">Classes</a>  and <a href="files.html">Files</a> are automatically generated by doxygen from the source code (and comments in the source code). These offer a much more indepth look into all classes and functions of this project. Note that only public and protected members of classes are documented.

* I recommend starting with \ref math and then testing the code examples inn \ref use, before moving to the automatically generated pages.


\page math The Math
\tableofcontents
\section sym Symmetric polynomials

Let \f$R=\mathbb Q[x_1,...,x_n]\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ and the fixed points \f$R^{\Sigma_n}\f$ i.e. the symmetric polynomials, form a polynomial algebra on the elementary symmetric polynomials: $$R^{\Sigma_n}=\mathbb Q[\sigma_1,...,\sigma_n]$$ where 
$$\sigma_k(x_1,...,x_n)=\sum_{1\le i_1< \cdots< i_k\le n}x_{i_1}....x_{i_k}$$
Furthermore, there is a simple algorithm for writing every symmetric polynomial on the \f$x_i\f$ as a polynomial on the \f$\sigma_i\f$. This library implements that algorithm.


\section symr Symmetric polynomials with 'half idempotent' relations

Let \f$R=\mathbb Q[x_1,...,x_n,y_1,...,y_n]/(y_i^2=y_i)\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ permuting the \f$x_i\f$ and \f$y_i\f$ variables separately. A minimal description of the \f$R^{\Sigma_n}\f$ is now more difficult:
$$R^{\Sigma_n}=\frac{\mathbb Q[\alpha,c_i,\beta_{s,t}]}{\sim}$$ where 
$$\alpha=y_1+\cdots+y_n$$
$$c_k=\sum_{1\le i_1< \cdots< i_k\le n}x_{i_1}....x_{i_k}$$
$$\beta_{s,t}=\sum_{1\le i_1< \cdots< i_s\le n\\
1\le j_1< \cdots< j_t\le n\\
i_u\neq j_v}x_{i_1}....x_{i_s}y_{j_1}\cdots y_{j_t}$$
where \f$1\le i\le n\f$ and \f$1\le s\le n\f$ and \f$1\le t\le n-s\f$.

The relations \f$\sim\f$ are:

$$\alpha^{n+1}=\alpha^n+\cdots$$
$$\alpha^s\beta_{s,i}=c_s\alpha^{i+s}+\cdots$$ 
$$\beta_{s,i}\beta_{t,j}=c_t\beta_{s,\min(i+j,n)}+\cdots$$ 
where \f$s\le t\le s+i\f$ for the last relation.

The first relation can be explicitly computed as:
$$	\alpha(\alpha-1)\cdots (\alpha-n)=0$$

This library implements an algorithm that can write every element in \f$R^{\Sigma_n}\f$ as a polynomial on the generators \f$\alpha,c_i,\beta_{s,t}\f$ and further produce every relation explicitly. The class \f$\alpha\f$ is referred to as "idempotent class" (since it's made out of idempotents), the classes \f$c_i\f$ are referred to as "Chern classes" and the classes \f$\beta_{s,t}\f$ are the "twisted Chern classes".

\section symrr Symmetric polynomials with other relations

More generally, the library can be extended to support more general situations, where the variables are partitioned into sets with different relations, and the various sets are permuted separately. In each case of course, a new algorithm must be implemented. The library can also be used to discover the algorithm in question, by brute force computing all relations if the generating set is known.

\page use How to Use
\tableofcontents
\section demo Quick Demonstration

For a quick demonstration you may compile the Demo.cpp. Eg (on Linux)

    clang++ source/Demo.cpp -std=c++17 -O3 -march=native -o Executable.out		

You can then run the file Executable.out. You can similarly do this over Windows using MSVC, producing a .exe file . Make sure to use the ```-std=c++17``` flag (or set the language options in an IDE to support C++17).

\section exa Code examples

\subsection namesp Namespaces

Everything in this library is under the namespace ```Symmetric_Polynomials```. For all the following code examples to work, start with

	using namespace Symmetric_Polynomials;

\subsection mono Monomials, polynomials and relations

A monomial is specified by its coefficient (```coeff```), powers vector (an ```std::vector<int> powers```) as well as template parameters for the type of coefficient (```scalar_t```) and relations (```rel_t```) used:  For example,

    monomial<int,norelations>(3,{0,1,4});
    
specifies the monomial \f$3x_2x_3^4\f$.

Any type with operations ```+,*,-,==``` and a constructor taking a single ```int``` type can be used as ```scalar_t```. In particular, we can use ```rational``` which represents rational numbers:

    monomial<rational,norelations> (rational(2,3),{0,1,4});

specifies the monomial \f$\frac23x_2x_3^4\f$.

As for ```rel_t```, this specifies both the degrees and relations the variables must satisfy. ```norelations``` means all variables \f$x_i\f$ have degree 1 and that there are no relations. On the other hand, ```halfidempotent``` means half the variables \f$x_i\f$ have degree 1, the 
other half \f$y_i\f$ have degree 0 and \f$y_i^2=y_i\f$ are the relations. For example:

    monomial<double,halfidempotent> (1.3,{3,1,4,1,0,1});

specifies the monomial \f$1.3x_1^3x_2x_3^4y_1y_3\f$

A polynomial is made out of a vector of monomials eg

    polynomial<int, halfidempotent>({monomial<int,halfidempotent>(2,{1,2,0,1}), monomial<int,halfidempotent>(3,{3,0,1,1})});
    
specifies the polynomial \f$2x_1x_2^2y_2+3x_1^3y_1y_2\f$.

\subsection perm Permutations

A permutation is an ```std::vector<char>``` and is applied on a monomial according to ```rel_t```: Eg for ```norelations``` we have a \f$\Sigma_n\f$ action on
\f$n\f$ many variables \f$x_1,...,x_n\f$, while for ```halfidempotent``` we have a \f$\Sigma_n\f$ action on \f$2n\f$ many variables \f$x_1,...,x_n\f$ and \f$y_1,...,y_n\f$ that are permuted separately.

\subsection sym Symmetric Polynomials and no relations

When we have no relations, we can use

	polynomial<rational, norelations> poly({ monomial<rational, norelations>(2, { 1,2 }), monomial<rational, norelations>(2, {2,1 }) }));
	decomposition_elementary_symmetric<rational> dec(poly);
	std::cout<< dec;

which sets ```poly``` to be \f$2x_1x_2^2+2x_1^2x_2\f$, computes the decomposition of ```poly``` into elementary symmetric polynomials ```e[i]``` (corresponding to \f$\sigma_i\f$), stores it into ```dec``` and prints the decomposition as: ```2e_1*e_2```. This all means that
$$2x_1x_2^2+2x_1^2x_2=2\sigma_1\sigma_2$$


The class ```decomposition_elementary_symmetric<rational>``` stores and computes the expression of a polynomial on variables \f$x_i\f$ as a polynomial on the \f$\sigma_i\f$.

\subsection halfidem Half idempotent relations

When we have the "half idempotent relation", the generators are \f$\alpha, c_i, \beta_{s,t}\f$ (see \ref math). In the program, ```Idem``` is the dominant term of \f$\alpha\f$, ```Chern``` is a vector containing the dominant terms of \f$c_1,...,c_n\f$ and ```TwistedChern``` is a 
vector containing the dominant terms of \f$\beta_{1,1},...,\beta_{1,n-1},\beta_{2,1},...,\beta_{n-1,1}\f$ in this order. To get the original indexing on the \f$\beta\f$ elements
we use ```std::map<std::pair<int,int>,int> TwistedChern_indexer``` eg

	std::cout << TwistedChern_indexer[std::make_pair<int,int>(1,2)];
	
prints ```1``` since ```TwistedChern[1]``` corresponds to \f$\beta_{1,2}\f$.

The code

	polynomial<rational, halfidempotent> poly({ monomial<rational, halfidempotent>(2, { 1,0,1,0 }), monomial<rational, halfidempotent>(2, {0,1,0,1 }) });
	decomposition_half_idempotent<rational> dec(poly);
	std::cout << dec << "\n";

sets ```poly``` to be \f$x_1y_1+x_2y_2\f$, computes the decomposition of ```poly``` into ```Idem,Chern,TwistedChern```, stores it into ```dec``` and prints the decomposition as ```2*a*c_1 + -2*b_{1,1}```
reflecting
$$x_1y_1+x_2y_2=2\alpha c_1-2\beta_{1,1}$$

The class ```decomposition_half_idempotent<rational>``` stores and computes the expression of a polynomial on variables \f$x_i,y_i\f$ as a polynomial on the \f$\alpha,c_i,\beta_{s,j}\f$.

To print the relations amongst \f$\alpha,c_i,\beta_{s,j}\f$ simply use:
	print_half_idempotent_relations<rational>(3);
	
The \f$3\f$ here corresponds to the number of variables: \f$x_1,x_2,x_3,y_1,y_2,y_3\f$ and can be replaced by any positive integer.

