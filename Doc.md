\mainpage General Information
\tableofcontents
 \section intro Introduction
This is a C++ header only library devoted to computations of symmetric polynomials on variables having relations. You can find the GitHub repository 
<a href="https://github.com/NickG-Math/Symmetric_Polynomials">here</a>. You can also find binaries for Windows and Linux if you want a quick demonstration <a href="https://github.com/NickG-Math/Symmetric_Polynomials/releases">here</a>.


\section req Requirements
 * A C++17 compiler, such as Clang (LLVM) or GCC or MSVC. 
 
\section install Installation

* To install simply clone/download the <a href="https://github.com/NickG-Math/Symmetric_Polynomials">repository</a> and include the "source" folder in your path. 

* See the page \ref use for a tutorial on using the library. For a brief explanation on the math behind it, see \ref math.

* As for compiler support, the latest version of the code is always tested with the latest stable versions of Clang, GCC (Linux) and MSVC (Windows). Remember to use the option ```-std=c++17```. 

\section doc Documentation

This documentation is organized in pages as follows:
 
* The pages \ref index, \ref math, \ref use, explain how the program works.

* The pages <a href="namespaces.html">Namespaces</a>, <a href="annotated.html">Classes</a>  and <a href="files.html">Files</a> are automatically generated by doxygen from the source code (and comments in the source code). These offer a much more in depth look into all classes and functions of this project. Note that only public and protected members of classes are documented.

* I recommend starting with \ref math and then testing the code examples in \ref use, before moving to the automatically generated pages.


\page math The Math
\tableofcontents
\section sym Symmetric polynomials

Let \f$R=\mathbb Z[x_1,...,x_n]\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ and the fixed points \f$R^{\Sigma_n}\f$ i.e. the symmetric polynomials, form a polynomial algebra on the elementary symmetric polynomials: $$R^{\Sigma_n}=\mathbb Z[\sigma_1,...,\sigma_n]$$ where 
$$\sigma_k(x_1,...,x_n)=\sum_{1\le i_1< \cdots< i_k\le n}x_{i_1}....x_{i_k}$$
Furthermore, there is a simple algorithm for writing every symmetric polynomial on the \f$x_i\f$ as a polynomial on the \f$\sigma_i\f$. This library implements that algorithm.


\section symr Symmetric polynomials with 'half idempotent' relations

Let \f$R=\mathbb Z[x_1,...,x_n,y_1,...,y_n]/(y_i^2=y_i)\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ permuting the \f$x_i\f$ and \f$y_i\f$ variables separately. A minimal description of the \f$R^{\Sigma_n}\f$ is now more difficult:
$$R^{\Sigma_n}=\frac{\mathbb Z[\gamma_{s,i}]}{\gamma_{s,i}\gamma_{t,j}={\min(i+j+s,n)-t}\choose {j}\gamma_{t,0}\gamma_{s,\min(i+j,n)}+\cdots}$$ where the "twisted Chern classes" are:
$$\gamma_{s,i}=\sum_{1\le j_1< \cdots< j_s\le n, 
1\le k_1< \cdots< k_i\le n\\
j_u\neq k_v}x_{j_1}....x_{j_s}y_{k_1}\cdots y_{k_i}$$
for \f$0\le s\le n\f$ and \f$0\le i\le n-s\f$. The relations require the indices \f$s,i,t,j\f$ to satisfy \f$s\le t\le s+i\f$ and \f$i,j>0\f$.

For convenience we set:
$$\alpha_i=\gamma_{0,i}=\sigma_i(y_1,...,y_n)$$
$$c_s=\gamma_{s,0}=\sigma_s(x_1,...,x_n)$$
Over \f$\mathbb Q\f$, the \f$\alpha_1^i\f$ can generate all \f$\alpha_i\f$ via:
$$\alpha_i=\frac{\alpha(\alpha-1)\cdots(\alpha-i+1)}{i!}$$
however for speed+numerical stability we prefer to use all \f$\alpha_i\f$ and have \f$\mathbb Z\f$ coefficients in our relations.

This library implements an algorithm that can write every element in \f$R^{\Sigma_n}\f$ as a polynomial on the generators \f$\alpha_i,c_i,\gamma_{s,i}\f$ and further produce every relation explicitly. 

The "twisted Pontryagin/symplectic classes" are defined as:
$$\kappa_{s,i}=\sum_{1\le j_1< \cdots< j_s\le n, 
1\le k_1< \cdots< k_i\le n\\
j_u\neq k_v}x^2_{j_1}....x^2_{j_s}y_{k_1}\cdots y_{k_i}$$
This library also allows one to write the \f$\kappa_{s,i}\f$ in terms of the \f$\gamma_{s,i}\f$

\page use How to Use
\tableofcontents
\section demo Quick Demonstration

For a quick demonstration you may use the binaries found <a href="https://github.com/NickG-Math/Symmetric_Polynomials/releases">here</a>. These are compiled from Demo.cpp using MSVC and Clang respectively. You can also compile these binaries yourself. For example, on Linux use:

    clang++ source/Demo.cpp -std=c++17 -O3 -fopenmp -march=native -o Lin64.out	

(disable -fopenmp if a multithreading is not desired; eg to save on resources and decrease total memory footprint).

You can similarly do this over Windows using MSVC, producing a .exe file . Make sure to use the ```-std=c++17``` flag (or set the language options in an IDE to support C++17).

\section exa Code examples

\subsection namesp Namespaces

Everything in this library is under the namespace ```Symmetric_Polynomials```. For all the following code examples to work, start with

	using namespace Symmetric_Polynomials;

\subsection mono Polynomials

A polynomial in multiple variables can be default constructed as:
	
	Polynomial<default_container<int, Standard_Variables<>>> p;
	
Let us explain the template parameters:
- ```int``` is the type of the scalar coefficients, so it can be replaced by ```float``` etc.
- ```Standard_Variables<>``` specifies that our variables are \f$x_1,...,x_n\f$ with degrees \f$|x_i|=1\f$ and no relations. It can be replaced by ```Half_Idempotent_Variables```
that specify variables \f$x_1,...,x_n,y_1,...,y_n\f$ with degrees \f$|x_i|=1, |y_i|=0\f$ and relations \f$y_i^2=y_i\f$.
- The ```default_container``` specifies the container used to store the monomials in the polynomial. See the advanced subsection below. 

To initialize a polynomial, provide the desired number of variables \f$n\f$. For example, if \f$n=3\f$:

	p=Polynomial<default_container<int, Standard_Variables<>>>(3);

Next, insert monomials \f$cx_1^{a_1}\cdots x_n^{a_n}\f$ by providing the exponent vector \f$[a_1,...,a_n]\f$ and the coefficient \f$c\f$. Eg:

	p.insert({0,1,4},7);

inserts the monomial \f$7x_2x_3^4\f$ in ```p```. If we further insert

	p.insert({1,1,2},-8);

then ```p``` becomes \f$-8x_1x_2x_3^2+7x_2x_3^4\f$ and printing it to console verifies that:

	std::cout << p << "\n";

 It is the user's responsibility to make sure that
- the number of variables is the length of the exponent vector being inserted
- the coefficient provided is never \f$0\f$
- not attempt to insert a monomial with an already existing exponent vector (doing so does not change the polynomial)

Polynomials can be added, subtracted and multiplied by binary operators ```+,-,*``` eg:

	std::cout << (p+(p^2))<< "\n";

will print 

$$-8x_1x_2x_3^2 + 7x_2x_3^4 + 64x_1^2x_2^2x_3^4 + -112x_1x_2^2x_3^6 + 49x_2^2x_3^8$$

\subsection sym Symmetric Basis

The class ```Symmetric_Basis_Default``` allows us to transform polynomials on \f$x_i\f$ variables (```Standard_Variables```) into polynomials on the elementary symmetric polynomials \f$e_i=\sigma_i\f$ (```Elementary_Symmetric_Variables```). For example:

	Symmetric_Basis_Default<int> SB(2);

	Polynomial<default_container<int, Standard_Variables<>>> poly(2);

	poly.insert({1,2},2);

	poly.insert({2,1},2);

	Polynomial<default_container<int, Elementary_Symmetric_Variables<>>>  new_poly= SB(poly);

	Polynomial<default_container<int, Standard_Variables<>>>  new_new_poly= SB(new_poly);

	std::cout << poly << "\n";

	std::cout<< new_poly << "\n";

	std::cout << new_new_poly << "\n";


does the following: First it sets ```poly``` to \f$2x_1x_2^2+2x_1^2x_2\f$, then transforms it in \f$e_i\f$ variables as ```new_poly``` which is \f$2e_1e_2\f$ and then transforms that back to \f$x_i\f$ variables as ```new_new_poly``` which is \f$2x_1x_2^2+2x_1^2x_2\f$ (i.e. the original polynomial) and finally prints the three polynomials. This all means that
$$2x_1x_2^2+2x_1^2x_2=2e_1e_2$$

\subsection halfidem Half idempotent relations

When we have the "half idempotent relation" i.e. variables \f$x_i,y_i\f$ with \f$y_i^2=y_i\f$ (as specified by ```Half_Idempotent_Variables```), the generators are \f$\alpha_i, c_i, \gamma_{s,t}\f$ (see \ref math) or ```Idem[i]```, ```Chern[i]``` and ```TwistedChern[s][t]``` respectively as they are used in the program. We order them as \f$\alpha_1,...,\alpha_n,c_1,...,c_n, \gamma_{1,1},...,\gamma_{1,n-1},\gamma_{2,1},...,\gamma_{n-1,1}\f$. 

The class ```Half_Idempotent_Basis_Default``` allows us to transform polynomials on \f$x_i,y_i\f$ variables (```Half_Idempotent_Variables```) into polynomials on the \f$\alpha_i,c_i,\gamma_{s,i}\f$ (```Twisted_Chern_Variables```).

The code

	Half_Idempotent_Basis_Default<int> HB(2);

	Polynomial<default_container<int, Half_Idempotent_Variables<>>> poly2(4);
	
	poly2.insert({ 1,0,1,0 }, 2);
	
	poly2.insert({ 0,1,0,1 }, 2);
	
	auto new_poly2= HB(poly2);
	
	auto new_new_poly2= HB(new_poly2);
	
	std::cout << poly2 << "\n";
	
	std::cout << new_poly2 << "\n";
	
	std::cout << new_new_poly2 << "\n";

sets ```poly``` to be \f$x_1y_1+x_2y_2\f$, transforms it into ```new_poly``` which is \f$2\alpha_1 c_1 + -2\gamma_{1,1}\f$ and then transforms it to ```new_new_poly``` in the original variables, which is equal to ```poly```, before printing their names. Thus:

$$x_1y_1+x_2y_2=-2\gamma_{1,1}+2\alpha_1 c_1$$

To print the relations amongst \f$\alpha_i,c_i,\gamma_{s,j}\f$ simply use:

	print_half_idempotent_relations<>(3,1,1);
	
The \f$3\f$ here corresponds to the half the number of variables: \f$x_1,x_2,x_3,y_1,y_2,y_3\f$ and can be replaced by any positive integer.

There is also a multithreaded version that you can compile yourself, by removing the comment from the #pragma omp in the definition of ```print_half_idempotent_relations```.


Finally, Demo.cpp contains another function, ```write_pontryagin_C2_in_terms_of_Chern_classes```. This prints the expressions of the twisted Pontryagin/symplectic classes given by

$$\pi_{s,t}=\kappa_{s,t}=\sum_{1\le i_1< \cdots< i_s\le n\\
1\le j_1< \cdots< j_t\le n\\
i_u\neq j_v}x^2_{i_1}....x^2_{i_s}y_{j_1}\cdots y_{j_t}$$

in terms of the \f$\alpha_i,c_i,\gamma_{s,t}\f$. 
For example, try running 

	write_pontryagin_C2_in_terms_of_Chern_classes(5);
	
	
\subsection adv Advanced

The ```default_container<scl_t, exp_t, ordered>``` specifies the data structure that should be used to internally store the monomials of the polynomial. This must have the features of an ordered/unordered map (degree,exponent)->coefficient. The boolean template parameter ```ordered``` specifies whether we want to use ```std::map``` (default) or ```std::unordered_map```. 
When unordered maps are used, it's important to:
- Reserve space for the amount of monomials to be inserted by eg: ```p.reserve(5);``` if we expect to store \f$5\f$ monomials
- Keep in mind that when iterating through the polynomial, the monomials won't be ordered. Same applies when printing the polynomial.
In general, using unordered maps is faster especially with a good hashing function (see \ref General.h for two possible hashing functions that can be used).

You can also use your own container instead of the ```default_container```. See the file \ref Polynomials.h for the exact requirements from 
a custom container.

Finally, the ```Symmetric_Basis_Default``` and ```Half_Idempotent_Basis_Default``` are aliases for ```Symmetric_Basis``` and ```Half_Idempotent_Basis``` that  accept containers as template parameters for extra customization.
