#define SYMMP_USE_OPEN_MP ///<Define this macro to enable openMP in the library (you will also need to enable openMP in your compiler).
#include "Half_Idempotent.hpp"

#include <chrono>

///	@file
///	@brief A demonstration file that can be compiled

using namespace symmp;

/// @brief					Writes the twisted Pontryagin (symplectic) classes \f$\pi_{s,j}\f$ (\f$\kappa_{s,j}\f$) in terms of the Chern classes under the forgetful \f$BU(n)\to BSO(n)\f$ (hermitianization \f$BU(n)\to BSp(n)\f$)
///	@tparam xy_poly_t		The type of polynomial on the \f$x_i,y_i\f$ variables
///	@tparam chern_poly_t	The type of polynomial on the \f$\gamma_{s,j}\f$ variables
/// @param	n				The \f$n\f$ in \f$BU(n), BSO(n), BSp(n)\f$
template <class xy_poly_t, class chern_poly_t>
void pontryagin_via_chern(int n)
{
	TwistedChernBasis<xy_poly_t, chern_poly_t> hib(n);
	SYMMP_RUN_LOOP_IN_PARALLEL
		for (int s = 1; s <= n; s++)
			for (int i = 1; i <= n - s; i++)
			{
				const auto& twistedChern = hib.generator(s, i);
				xy_poly_t twistedPontryagin;
				for (auto it = twistedChern.begin(); it != twistedChern.end(); ++it)
					twistedPontryagin.insert(it.exponent() + it.exponent(), it.coeff());
				std::stringstream ss;
				ss << "k_{" << s << "," << i << "}= " << hib(twistedPontryagin) << "\n";
				std::cout << ss.str();
			}
}

/// @brief User facing interface for computing relations/writing Pontryagin/symplectic in terms of Chern.
void show_and_tell()
{
	typedef Poly<int64_t, HalfIdempotentVariables<uint64_t, uint64_t>, 0> xy_poly_t;
	typedef Poly<int64_t, TwistedChernVariables<uint64_t, uint64_t>, 0> chern_poly_t;

	std::cout << "Consider the polynomial ring (over Z) with variables x_1,...,x_n,y_1,...,y_n and relations y_i^2=y_i \n";
	std::cout << "The symmetric group Sigma_n acts on this ring by separately permuting the x_i,y_i separately\n";
	std::cout << "The invariants under this action can be minimally generated by the \"twisted Chern classes\" c_{s,j} \n\n";
	std::cout << "Each c_{s,j} is the sum of all elements in the Sigma_n-orbit of x_1....x_sy_{s+1}....y_{s+j}\n";
	std::cout << "For j=0 we have the elementary symmetric polynomials c_s on x_1,...,x_n\n";
	std::cout << "For s=0 we have the elementary symmetric polynomials a_j on y_1,...,y_n\n";
	std::cout << "Over the rationals, we can actually explicitly generate all a_j from a_1, but in the interest of speed/numerical stability, this computation uses all a_j\n\n";
	std::cout << "We can similarly define the twisted Pontryagin/symplectic classes k_{s,j} as the sum of all elements in the Sigma_n-orbit of x_1^2....x_s^2y_{s+1}....y_{s+j}\n\n";

	std::cout << "This demo program can compute the relations between the twisted Chern classes or write the twisted Pontryagin/symplectic classes in terms of the twisted Chern classes\n";
	std::cout << "Enter 0 if you want the former and 1 if you want the latter. Enter any other number to exit the program.\n";
	std::cout << "Waiting for user input: \n";
	int opt;
	std::cin >> opt;
	if (opt == 0)
	{
		std::cout << "\nThe twisted Chern classes satisfy relations c_{s,i}*c_{t,j}=c_{t,0}c_{s,min(i+j,n-s)}+... when s<=t<=s+i and i,j>0.\n";
		std::cout << "As we can obtain the a_j from just the a_1, we only really need to compute the relations when s,t>0 or s==0, i==t.\n\n";
		while (true)
		{
			std::cout << "Enter the number n>=2 of variables x_1,..., x_n,y_1,...,y_n and these relations for the given n will be printed\n";
			std::cout << "To exit the program enter any n<=1\n";
			std::cout << "Waiting for user input:\n";
			int n;
			std::cin >> n;
			if (n <= 1)
			{
				std::cout << "Program exited by user request. \n";
				return;
			}
			else
			{
				std::cout << "The relations for n= " << n << " follow: \n";
				print_half_idempotent_relations<xy_poly_t, chern_poly_t>(n, 1, 0, 0);
				std::cout << "\n\n";
			}
		}
	}
	if (opt == 1)
	{
		while (true)
		{
			std::cout << "\nEnter the number n>=2 of variables x_1,..., x_n,y_1,...,y_n and the twisted Pontryagin classes k_{s,j} for s+j<=n will be written in terms of the c_{s,j}\n";
			std::cout << "To exit the program enter any n<=1\n";
			std::cout << "Waiting for user input:\n";
			int n;
			std::cin >> n;
			if (n <= 1)
			{
				std::cout << "Program exited by user request. \n";
				return;
			}
			else
			{
				std::cout << "The twisted Pontryagin/symplectic classes k_{s,j} in terms of the twisted Chern classes c_{s,j} for s+j<=" << n << " follow:\n";
				pontryagin_via_chern<xy_poly_t, chern_poly_t>(n);
				std::cout << "\n\n";
			}
		}
	}
	else
	{
		std::cout << "Program exited by user request. \n";
		return;
	}
}

/// @brief				Optimized speedtest (no console output). For benchmarking and regression testing
///	@tparam scl_t		The type of scalars eg int
///	@tparam exp_val_t	The value type of the exponent vectors
///	@tparam deg_t		The type of the degree of the monomials
template <class scl_t, class exp_val_t, class deg_t>
void speed_test()
{
	constexpr int varcount = 9;
	typedef Poly<int64_t, HalfIdempotentVariables<uint64_t, uint64_t>, 0> xy_poly_t;
	typedef Poly<int64_t, TwistedChernVariables<uint64_t, uint64_t>, 0> chern_poly_t;
	auto start = std::chrono::high_resolution_clock::now();
	print_half_idempotent_relations<xy_poly_t, chern_poly_t>(varcount, 0, 0, 0);
	auto end = std::chrono::high_resolution_clock::now();
	std::cout << varcount << " many variables took: " << std::chrono::duration_cast<std::chrono::seconds>(end - start).count() << "seconds\n";
}

///	@brief	Main
int main()
{
	using namespace symmp;

	show_and_tell();
	//speed_test<int64_t,uint8_t,uint16_t>();

	//code examples follow

	//Poly<int, StandardVariables<>> p;
	//p.insert({ 0,1,4 }, 7);
	//p.insert({ 1,1,2 }, -8);
	//std::cout << p << "\n" << (p + (p ^ 2)) << "\n";

	//Poly<double, ElementarySymmetricVariables<>> q({ 2,3 }, -1.5);
	//std::cout << q << "\n";

	//typedef Poly<double, StandardVariables<>> x_poly_t;
	//typedef Poly<double, ElementarySymmetricVariables<>> e_poly_t;

	//SymmetricBasis<x_poly_t, e_poly_t> SB(2);
	//Poly<double, StandardVariables<>> qx = SB(q);
	//std::cout << qx << "\n";

	//auto qe = SB(qx);
	//std::cout << qe << "\n";

	//typedef Poly<int, HalfIdempotentVariables<>> xy_poly_t;
	//typedef Poly<int, TwistedChernVariables<>> chern_poly_t;
	//xy_poly_t r;
	//r.insert({ 1,0,1,0 }, 2);
	//r.insert({ 0,1,0,1 }, 2);
	//TwistedChernBasis<xy_poly_t, chern_poly_t> TCB(2);
	//std::cout << TCB(r);

	//std::cout << TCB(TCB(r));

	//print_half_idempotent_relations<xy_poly_t, chern_poly_t>(3);
	//pontryagin_via_chern < xy_poly_t, chern_poly_t>(5);
	return 0;
}
