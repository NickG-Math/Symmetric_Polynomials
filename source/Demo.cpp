#include "Half_Idempotent.h"
#include <chrono>
///@file
///@brief A demonstration file that can be compiled

using namespace Symmetric_Polynomials;


///Writes the twisted Pontryagin/symplectic classes pi_{s,j}/k_{s,j} in terms of the Chern classes under the forgetful map BU(n)->BSO(n) / hermitianization BU(n) -> BSp(n)
template<typename HIB= Half_Idempotent_Basis_Default<int64_t>>
void write_pontryagin_C2_in_terms_of_Chern_classes(int n)
{
	HIB hib(n);
	for (int s = 1; s <= n; s++)
		for (int i = 1; i <= n - s; i++) {
			auto twistedChern = hib.generator(s,i);
			decltype(twistedChern) twistedPontryagin(hib.number_of_variables);
			for (auto it = twistedChern.begin(); it != twistedChern.end(); ++it)
				twistedPontryagin.insert(it.exponent() + it.exponent(), it.coeff());
			std::cout << "k_{" << s << "," << i << "}= ";
			std::cout << hib(twistedPontryagin) << "\n";
		}
}

void show_and_tell() {

	std::cout << "Consider the polynomial ring (over Z) with variables x_1,...,x_n,y_1,...,y_n and relations y_i^2=y_i \n";
	std::cout << "The symmetric group Sigma_n acts on this ring by separately permuting the x_i,y_i separately\n";
	std::cout << "The invariants under this action can be minimally generated by the \"twisted Chern classes\" c_{s,j} \n\n";
	std::cout << "Each c_{s,j} is the sum of all elements in the Sigma_n-orbit of x_1....x_sy_{s+1}....y_{s+j}\n";
	std::cout << "For j=0 we have the elementary symmetric polynomials c_s on x_1,...,x_n\n";
	std::cout << "For s=0 we have the elementary symmetric polynomials a_j on y_1,...,y_n\n";
	std::cout << "Over the rationals, we can actually explicitly generate all a_j from a_1, but in the interest of speed/numerical stability, this computation uses all a_j\n\n";
	std::cout << "We can similarly define the twisted Pontryagin/symplectic classes k_{s,j} as the sum of all elements in the Sigma_n-orbit of x_1^2....x_s^2y_{s+1}....y_{s+j}\n\n";


	std::cout << "This demo program can compute the relations between the twisted Chern classes or write the twisted Pontryagin/symplectic classes in terms of the twisted Chern classes\n";
	std::cout << "Enter 0 if you want the former and 1 if you want the latter. Enter any other number to exit the program.\n";
	std::cout << "Waiting for user input: \n";
	int opt;
	std::cin >> opt;
	if (opt == 0) {
		std::cout << "\nThe twisted Chern classes satisfy relations c_{s,i}*c_{t,j}=c_{t,0}c_{s,min(i+j,n-s)}+... when s<=t<=s+i and i,j>0.\n";
		std::cout << "As we can obtain the a_j from just the a_1, we only really need to compute the relations when s,t>0 or s==0, i==t.\n\n";
		while (true) {
			std::cout << "Enter the number n>=2 of variables x_1,..., x_n,y_1,...,y_n and these relations for the given n will be printed" << "\n";
			std::cout << "To exit the program enter any n<=1" << "\n";
			std::cout << "Waiting for user input:\n";
			int n;
			std::cin >> n;
			if (n <=1) {
				std::cout << "Program exited by user request. \n";
				return;
			}
			else {
				std::cout << "The relations for n= " << n << " follow:" << "\n";
				print_half_idempotent_relations(n, 1);
				std::cout << "\n\n";
			}
		}
	}
	if (opt == 1) {
		while (true) {
			std::cout << "\nEnter the number n>=2 of variables x_1,..., x_n,y_1,...,y_n and the twisted Pontryagin classes k_{s,j} for s+j<=n will be written in terms of the c_{s,j}" << "\n";
			std::cout << "To exit the program enter any n<=1" << "\n";
			std::cout << "Waiting for user input:\n";
			int n;
			std::cin >> n;
			if (n <= 1) {
				std::cout << "Program exited by user request. \n";
				return;
			}
			else {
				std::cout << "The twisted Pontryagin/symplectic classes k_{s,j} in terms of the twisted Chern classes c_{s,j} for s+j<=" << n << " follow:" << "\n";
				write_pontryagin_C2_in_terms_of_Chern_classes<>(n);
				std::cout << "\n\n";
			}
		}
	}
	else {
		std::cout << "Program exited by user request. \n";
		return;
	}

}

template<typename scl_t, typename exp_value_t, typename deg_t>
void speed_test() {
	constexpr int varcount = 9;
	std::chrono::time_point<std::chrono::high_resolution_clock> start, end;
	start = std::chrono::high_resolution_clock::now();
	print_half_idempotent_relations<Half_Idempotent_Basis<default_container<scl_t, Half_Idempotent_Variables<exp_value_t, deg_t, 2 * varcount>, 0>, default_container<scl_t, Twisted_Chern_Variables<exp_value_t, deg_t>, 0>>>(varcount);
	end = std::chrono::high_resolution_clock::now();
	std::cout << varcount << " many variables took: " << std::chrono::duration_cast<std::chrono::seconds>(end - start).count() << "seconds" << "\n";
}

int main() {
	using namespace Symmetric_Polynomials;
		
	show_and_tell();
	//speed_test<int64_t,uint8_t,uint16_t>();

	//If we know the number of variables by compile time we can use that information with half_idempotent:
	//constexpr int n = 4;
	//print_half_idempotent_relations2<Rational, Half_Idempotent_Variables<T, 2*n>>(n, 1, 1);

	//code examples
	//Polynomial<default_container<int, Standard_Variables<>>> p;
	//p=Polynomial<default_container<int, Standard_Variables<>>>(3);
	//p.insert({0,1,4},7);
	//p.insert({1,1,2},-8);
	//std::cout << p << "\n";
	//std::cout << (p+(p^2))<< "\n";

	//Symmetric_Basis_Default<int> SB(2);
	//Polynomial<default_container<int, Standard_Variables<>>> poly(2);
	//poly.insert({1,2},2);
	//poly.insert({2,1},2);
	//Polynomial<default_container<int, Elementary_Symmetric_Variables<>>>  new_poly= SB(poly);
	//Polynomial<default_container<int, Standard_Variables<>>>  new_new_poly= SB(new_poly);
	//std::cout << poly << "\n";
	//std::cout<< new_poly << "\n";
	//std::cout << new_new_poly << "\n";

	//Half_Idempotent_Basis_Default<int> HB(2);
	//Polynomial<default_container<int, Half_Idempotent_Variables<>>> poly2(4);
	//poly2.insert({ 1,0,1,0 }, 2);
	//poly2.insert({ 0,1,0,1 }, 2);
	//auto new_poly2= HB(poly2);
	//auto new_new_poly2= HB(new_poly2);
	//std::cout << poly2 << "\n";
	//std::cout << new_poly2 << "\n";
	//std::cout << new_new_poly2 << "\n";

	//print_half_idempotent_relations<>(3,1,1);
	//write_pontryagin_C2_in_terms_of_Chern_classes(5);
	return 0;

}
