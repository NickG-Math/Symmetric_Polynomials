\mainpage General Information
\tableofcontents
 \section intro Introduction
This is a C++ header only library devoted to computations of symmetric polynomials on variables having relations. You can find the GitHub repository 
<a href="https://github.com/NickG-Math/Symmetric_Polynomials">here</a>. You can also find binaries for Windows and Linux if you want a quick demonstration <a href="https://github.com/NickG-Math/Symmetric_Polynomials/releases">here</a>.


\section req Requirements
 * A C++17 compiler, such as Clang (LLVM), GCC or MSVC. 
 
\section install Installation

* To install simply clone/download the <a href="https://github.com/NickG-Math/Symmetric_Polynomials">repository</a> and include the "source" folder in your path. 

* See the page \ref use for a tutorial on using the library. For a brief explanation on the math behind it, see \ref math.

* The latest version of the code is always tested with the latest stable versions of Clang, GCC (Linux) and MSVC (Windows). Remember to use the option ```-std=c++17```. 

\section doc Documentation

This documentation is organized in pages as follows:
 
* The pages \ref index, \ref math, \ref use, explain how the program works.

* The pages <a href="namespaces.html">Namespaces</a>, <a href="annotated.html">Classes</a>  and <a href="files.html">Files</a> are automatically generated by doxygen from the source code (and comments in the source code). These offer a much more in depth look into all classes and functions of this project. Note that only public and protected members of classes are documented.

* I recommend starting with \ref math and then testing the code examples in \ref use, before moving to the automatically generated pages.

\section fut Future Update Plans

* Use C++20 features: Concepts, Coroutines and Modules

\page math The Math
\tableofcontents
\section sym Symmetric polynomials

Let \f$R=\mathbf Z[x_1,...,x_n]\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ and the fixed points \f$R^{\Sigma_n}\f$ i.e. the symmetric polynomials, form a polynomial algebra on the elementary symmetric polynomials: 
\f[R^{\Sigma_n}=\mathbf Z[\sigma_1,...,\sigma_n]\f] where 
\f[\sigma_k(x_1,...,x_n)=\sum_{1\le i_1< \cdots< i_k\le n}x_{i_1}....x_{i_k}\f]
Furthermore, there is a simple algorithm for writing every symmetric polynomial on the \f$x_i\f$ as a polynomial on the \f$\sigma_i\f$. This library implements that algorithm.


\section hir Symmetric polynomials with 'half idempotent' relations

Let \f$R=\mathbf Z[x_1,...,x_n,y_1,...,y_n]/(y_i^2=y_i)\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ permuting the \f$x_i\f$ and \f$y_i\f$ variables separately. A minimal description of the \f$R^{\Sigma_n}\f$ is now more difficult:
\f[R^{\Sigma_n}=\frac{\mathbf Z[\gamma_{s,i}]}{\gamma_{s,i}\gamma_{t,j}=r_{n,s,i,t,j}\gamma_{t,0}\gamma_{s,\min(i+j,n)}+\cdots}\f] where the "twisted Chern classes" are:
\f[\gamma_{s,i}=
\sum_{1\le j_1< \cdots< j_s\le n, 1\le k_1< \cdots< k_i\le n\\ j_u\neq k_v}
x_{j_1}....x_{j_s}y_{k_1}\cdots y_{k_i}\f]
for \f$0\le s\le n\f$ and \f$0\le i\le n-s\f$. The coefficient \f$r_{n,s,i,t,j}\f$ in the relations is given by the binomial:
\f[{\min(i+j+s,n)-t}\choose {j}\f] 
Moreover, the relations require the indices \f$s,i,t,j\f$ to satisfy \f$s\le t\le s+i\f$ and \f$i,j>0\f$.

For convenience we set:
\f[\alpha_i=\gamma_{0,i}=\sigma_i(y_1,...,y_n)\f]
\f[c_s=\gamma_{s,0}=\sigma_s(x_1,...,x_n)\f]
Over \f$\mathbf Q\f$, the \f$\alpha_1^i\f$ can generate all \f$\alpha_i\f$ via:
\f[\alpha_i=\frac{\alpha(\alpha-1)\cdots(\alpha-i+1)}{i!}\f]
however for speed+numerical stability we prefer to use all \f$\alpha_i\f$ and have \f$\mathbf Z\f$ coefficients in our relations.

This library implements an algorithm that can write every element in \f$R^{\Sigma_n}\f$ as a polynomial on the generators \f$\alpha_i,c_i,\gamma_{s,i}\f$ and further produce every relation explicitly. 

The "twisted Pontryagin/symplectic classes" are defined as:
\f[\kappa_{s,i}=\sum_{1\le j_1< \cdots< j_s\le n, 
1\le k_1< \cdots< k_i\le n\\
j_u\neq k_v}x^2_{j_1}....x^2_{j_s}y_{k_1}\cdots y_{k_i}\f]
This library also allows one to write the \f$\kappa_{s,i}\f$ in terms of the \f$\gamma_{s,i}\f$

\page use How to Use
\tableofcontents
\section demo Quick Demonstration

For a quick demonstration you may use the binaries found <a href="https://github.com/NickG-Math/Symmetric_Polynomials/releases">here</a>. These are compiled from Demo.cpp using MSVC (Windows) and GCC (Linux). You can also compile these binaries yourself. For example, on Linux use:

    g++ source/Demo.cpp -std=c++17 -O3 -fopenmp -march=native -o Lin64.out	

Only the ```-std=c++17``` flag is required.

\section exa Code examples

\subsection namesp Namespaces

Everything in this library is under the namespace \ref symmp (short for Symmetric Polynomials). To keep names short, the code examples will assume we are using this namespace. So start with:

	using symmp;

\subsection mono Polynomials

A polynomial \f$p\f$ in the graded ring \f$\mathbf Z[x_1,...,x_n]\f$, \f$|x_i|=1\f$, can be declared as:
	
	OrderedPolynomial<int, StandardVariables<>> p;

Here:
- \ref symmp::OrderedPolynomial means that the monomials of the polynomial are kept in increasing order. See below for alternatives.
- ```int``` is the type of the scalar coefficients (i.e. elements of the base ring; in our case \f$\mathbf Z\f$), so it can be replaced by ```double``` etc.
- \ref symmp::StandardVariables specify we have variables of degree \f$1\f$, names \f$x_i\f$ and no relations. See the next few subsections for alternatives.

To insert a monomial \f$cx_1^{a_1}\cdots x_n^{a_n}\f$ in \f$p\f$ we provide the exponent vector \f$[a_1,...,a_n]\f$ and the coefficient \f$c\f$. Eg:

	p.insert({0,1,4},7);

inserts the monomial \f$7x_2x_3^4\f$ in \f$p\f$. If we further do:

	p.insert({1,1,2},-8);

then \f$p\f$ becomes \f$-8x_1x_2x_3^2+7x_2x_3^4\f$. We can verify that by printing it to the console:

	std::cout << p << "\n";

When inserting keep in mind that:
- every exponent vector must have the same length (number of variables)
- the coefficients provided must never be \f$0\f$
- attempting to insert a monomial with an already existing exponent vector does nothing

Polynomials can be added, subtracted and multiplied by binary operators ```+,-,*``` eg:

	std::cout << (p+(p^2))<< "\n";

will print 

$$-8x_1x_2x_3^2 + 7x_2x_3^4 + 64x_1^2x_2^2x_3^4 - 112x_1x_2^2x_3^6 + 49x_2^2x_3^8$$

which is exactly \f$p+p^2\f$.

Instead of \ref symmp::OrderedPolynomial, we can also use \ref symmp::UnorderedPolynomial which does not store the monomials in increasing order. This has performance benefits (internal data structure is \c std::unordered_map as opposed to \c std::map). Ordered and unordered polynomials have the exact same API.


\subsection symbasis Symmetric Basis

Apart from the  \ref symmp::StandardVariables, we can also use the 	\ref symmp::ElementarySymmetricVariables which specify variables with names \f$e_i\f$, degrees \f$|e_i|=i\f$ and no relations. 

Example: An element \f$q\f$ of the ring \f$\mathbf R[e_1,...,e_n]\f$ can be defined as: 

	OrderedPolynomial<double, ElementarySymmetricVariables<>> q({ 2,3 }, -1.5);
	std::cout << q << "\n";

which will print \f$-1.5e_1e_2\f$. We used the constructor that takes a single monomial in the form of exponent+vector.

To keep names short let us use the following two typedefs:

	typedef OrderedPolynomial<double, StandardVariables<>> x_var_t;
	typedef OrderedPolynomial<double, ElementarySymmetricVariables<>> e_var_t;

We can view \f[\mathbf R[e_1,...,e_n]=\mathbf R[x_1,...,x_n]^{\Sigma_n}\f] with \f$e_i=\sigma_i\f$ being the elementary symmetric polynomials. 
To convert \f$q\f$ from \f$e_i\f$ variables to \f$x_i\f$ variables we use the class  \ref symmp::SymmetricBasis :

	SymmetricBasis<x_var_t, e_var_t> SB(2);

The ```2``` signifies that we are using two variables \f$x_1,x_2\f$. Then:

	auto qx=SB(q);
	std::cout << qx;

will define an ```x_var_t qx``` that is ```q``` transformed into the \ref symmp::StandardVariables and print \f[-1.5x_1^3x_2^5 + -3x_1^4x_2^4 + -1.5x_1^5x_2^3\f]

We can perform the conversion the other way as well: given a polynomial in \ref symmp::StandardVariables such as ```qx``` we can use the ```SB``` from before to transform it into a polynomial on the 	\ref symmp::ElementarySymmetricVariables : 

	auto qe=SB(qx);
	std::cout << qe;

which will print \f$-1.5e_1e_2\f$. Observe that ```q==qe```;

\subsection halfidem Twisted Chern Basis

We can generate
\f[(R[x_1,...,x_n,y_1,...,y_n]/y_i^2=y_i)^{\Sigma_n}\f]

by the \f$\alpha_i, c_i, \gamma_{s,t}\f$ (see \ref math).

The class \ref symmp::TwistedChernBasis allows us to transform polynomials on \f$x_i,y_i\f$ variables (\ref symmp::HalfIdempotentVariables) into polynomials on the \f$\alpha_i,c_i,\gamma_{s,i}\f$ (\ref symmp::TwistedChernVariables).

Example:

	typedef UnorderedPolynomial<int, HalfIdempotentVariables<>> xy_var_t;
	typedef UnorderedPolynomial<int, TwistedChernVariables<>>> chern_var_t;
	xy_var_t poly;
	poly.insert({ 1,0,1,0 }, 2);
	poly.insert({ 0,1,0,1 }, 2);
	TwistedChernBasis<xy_var_t, chern_var_t> TCB(2);
	std::cout << TCB(poly);

sets ```poly``` to be \f$x_1y_1+x_2y_2\f$, transforms it into \f$\gamma_{s,j}\f$ variables and prints:

\f[-2\gamma_{1,1}+2\alpha_1 c_1\f]

And indeed:

\f[x_1y_1+x_2y_2=-2\gamma_{1,1}+2\alpha_1 c_1\f]

If we perform the transformation again we get the original polynomial: 

	std::cout << TCB(TCB(poly));

prints \f$x_1y_1+x_2y_2\f$. 

We note that the argument ```2``` in the constructor of ```TCB``` is half the number of variables \f$x_1,x_2,y_1,y_2\f$.


To print the relations amongst \f$\alpha_i,c_i,\gamma_{s,j}\f$ use:

	print_half_idempotent_relations<xy_var_t, chern_var_t>(3,1,1);
	
The \f$3\f$ here corresponds to the half the number of variables: \f$x_1,x_2,x_3,y_1,y_2,y_3\f$ and can be replaced by any positive integer.

Finally, Demo.cpp contains another function, ```write_pontryagin_C2_in_terms_of_Chern_classes```. This prints the expressions of the twisted Pontryagin/symplectic classes given by

\f[\pi_{s,t}=\kappa_{s,t}=\sum_{1\le i_1< \cdots< i_s\le n\\
1\le j_1< \cdots< j_t\le n\\
i_u\neq j_v}x^2_{i_1}....x^2_{i_s}y_{j_1}\cdots y_{j_t}\f]

in terms of the \f$\alpha_i,c_i,\gamma_{s,t}\f$. 
For example, try running 

	write_pontryagin_C2_in_terms_of_Chern_classes < xy_var_t, chern_var_t>(5);