\mainpage General Information
\tableofcontents
 \section intro Introduction
This is a C++ header only library devoted to computations of symmetric polynomials on variables having relations. You can find the GitHub repository 
<a href="https://github.com/NickG-Math/Symmetric_Polynomials">here</a>. You can also find binaries for Windows and Linux if you want a quick demonstration <a href="https://github.com/NickG-Math/Symmetric_Polynomials/releases">here</a>.


\section req Requirements
 * A C++17 compiler, such as Clang (LLVM), GCC or MSVC. 
 
\section install Installation

* To install simply clone/download the <a href="https://github.com/NickG-Math/Symmetric_Polynomials">repository</a> and include the "source" folder in your path. 

* See the page \ref use for a tutorial on using the library. For a brief explanation on the math behind it, see \ref math.

* The latest version of the code is always tested with the latest stable versions of Clang, GCC (Linux) and MSVC (Windows). Remember to use the option ```-std=c++17```. 

\section doc Documentation

This documentation is organized in pages as follows:
 
* The pages \ref index, \ref math, \ref use, explain how the program works.

* The pages <a href="namespaces.html">Namespaces</a>, <a href="annotated.html">Classes</a>  and <a href="files.html">Files</a> are automatically generated by doxygen from the source code (and comments in the source code). These offer a much more in depth look into all classes and functions of this project. Note that only public and protected members of classes are documented.

* I recommend starting with \ref math and then testing the code examples in \ref use, before moving to the rest of the pages.

\page math The Math
\tableofcontents
\section sym Symmetric polynomials

Let \f$R=\mathbf Z[x_1,...,x_n]\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ and the fixed points \f$R^{\Sigma_n}\f$ i.e. the symmetric polynomials, form a polynomial algebra on the elementary symmetric polynomials: 
\f[R^{\Sigma_n}=\mathbf Z[\sigma_1,...,\sigma_n]\f] where 
\f[\sigma_k(x_1,...,x_n)=\sum_{1\le i_1< \cdots< i_k\le n}x_{i_1}....x_{i_k}\f]
Furthermore, there is a simple algorithm for writing every symmetric polynomial on the \f$x_i\f$ as a polynomial on the \f$\sigma_i\f$. This library implements that algorithm.


\section hir Symmetric polynomials with 'half idempotent' relations

Let \f$R=\mathbf Z[x_1,...,x_n,y_1,...,y_n]/(y_i^2=y_i)\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ permuting the \f$x_i\f$ and \f$y_i\f$ variables separately. A minimal description of the \f$R^{\Sigma_n}\f$ is now more difficult:
\f[R^{\Sigma_n}=\frac{\mathbf Z[\gamma_{s,i}]}{\gamma_{s,i}\gamma_{t,j}=r_{n,s,i,t,j}\gamma_{t,0}\gamma_{s,\min(i+j,n)}+\cdots}\f] where the "twisted Chern classes" are:
\f[\gamma_{s,i}=
\sum_{1\le j_1< \cdots< j_s\le n, 1\le k_1< \cdots< k_i\le n\\ j_u\neq k_v}
x_{j_1}....x_{j_s}y_{k_1}\cdots y_{k_i}\f]
for \f$0\le s\le n\f$ and \f$0\le i\le n-s\f$. The coefficient \f$r_{n,s,i,t,j}\f$ in the relations is given by the binomial:
\f[{\min(i+j+s,n)-t}\choose {j}\f] 
Moreover, the relations require the indices \f$s,i,t,j\f$ to satisfy \f$s\le t\le s+i\f$ and \f$i,j>0\f$.

For convenience we set:
\f[\alpha_i=\gamma_{0,i}=\sigma_i(y_1,...,y_n)\f]
\f[c_s=\gamma_{s,0}=\sigma_s(x_1,...,x_n)\f]
Over \f$\mathbf Q\f$, the \f$\alpha_1^i\f$ can generate all \f$\alpha_i\f$ via:
\f[\alpha_i=\frac{\alpha(\alpha-1)\cdots(\alpha-i+1)}{i!}\f]
however for speed+numerical stability we prefer to use all \f$\alpha_i\f$ and have \f$\mathbf Z\f$ coefficients in our relations.

This library implements an algorithm that can write every element in \f$R^{\Sigma_n}\f$ as a polynomial on the generators \f$\alpha_i,c_i,\gamma_{s,i}\f$ and further produce every relation explicitly. 

The "twisted Pontryagin/symplectic classes" are defined as:
\f[\kappa_{s,i}=\sum_{1\le j_1< \cdots< j_s\le n, 
1\le k_1< \cdots< k_i\le n\\
j_u\neq k_v}x^2_{j_1}....x^2_{j_s}y_{k_1}\cdots y_{k_i}\f]
This library also allows one to write the \f$\kappa_{s,i}\f$ in terms of the \f$\gamma_{s,i}\f$

\page use How to Use
\tableofcontents
\section demo Quick Demonstration

For a quick demonstration you may use the binaries found <a href="https://github.com/NickG-Math/Symmetric_Polynomials/releases">here</a>. These are compiled from Demo.cpp using MSVC (Windows) and GCC (Linux). You can also compile these binaries yourself: For example, on Linux and from within the ```source``` folder use:

    g++ Demo.cpp -std=c++17 -O3 -fopenmp -march=native -o Lin64.out	

Only the ```-std=c++17``` flag is required; the other flags are for optimization.

\section exa Code examples

\subsection namesp Namespaces

Everything in this library is under the namespace \ref symmp (short for Symmetric Polynomials). The code examples that follow will assume we are using this namespace.\n
So start with:

	using symmp;

\subsection mono Polynomials

A polynomial \f$p\f$ in the graded ring \f$\mathbf Z[x_1,...,x_n]\f$, \f$|x_i|=1\f$, can be declared as:
	
	Poly<int, StandardVariables<>> p;

Here:
- ```int``` is the type of the scalar coefficients (i.e. elements of the base ring which in this case is \f$\mathbf Z\f$), so it can be replaced by ```double``` and even 
user-defined scalar types.
- \ref symmp::StandardVariables specifies variables in degree \f$1\f$, with names \f$x_i\f$ and no relations. We shall explain alternative variable configurations in the next few subsections.

To insert a monomial \f$cx_1^{a_1}\cdots x_n^{a_n}\f$ in \f$p\f$ simply provide the exponent vector \f$[a_1,...,a_n]\f$ and the coefficient \f$c\f$. \n
For example,

	p.insert({0,1,4},7);

inserts the monomial \f$7x_2x_3^4\f$ in \f$p\f$. \n
If we further write:

	p.insert({1,1,2},-8);

then \f$p\f$ becomes \f$-8x_1x_2x_3^2+7x_2x_3^4\f$.\n
We can verify that by printing it to the console:

	std::cout << p << "\n";

When inserting monomials in a polynomial, it is the user's responsibility to ensure that:
- all exponent vectors have the same length (number of variables) and are distinct
- the scalar coefficients are never \f$0\f$

Polynomials of the same type and number of variables can be added, subtracted and multiplied via binary operators ```+,-,*``` and raised to a nonnegative integer power by ```^```
For example:

	std::cout << (p+(p^2))<< "\n";

will print 

$$-8x_1x_2x_3^2 + 7x_2x_3^4 + 64x_1^2x_2^2x_3^4 - 112x_1x_2^2x_3^6 + 49x_2^2x_3^8$$

which is exactly \f$p+p^2\f$.

\subsection symbasis Symmetric Basis

We can substitute \ref symmp::StandardVariables with \ref symmp::ElementarySymmetricVariables specifying variables with names \f$e_i\f$, degrees \f$|e_i|=i\f$ and no relations. 

Example: The element \f$q=-1.5e_1e_2\f$ of the graded ring \f$\mathbf R[e_1,...,e_n], |e_i|=i\f$, can be defined as: 

	Poly<double, ElementarySymmetricVariables<>> q({ 2,3 }, -1.5);
	
We used the constructor that takes a single monomial in the form of exponent+vector.

For brevity let us use the following two typedefs:

	typedef Poly<double, StandardVariables<>> x_poly_t;
	typedef Poly<double, ElementarySymmetricVariables<>> e_poly_t;

Now we view \f[\mathbf R[e_1,...,e_n]=\mathbf R[x_1,...,x_n]^{\Sigma_n}\f] with \f$e_i=\sigma_i\f$ being the elementary symmetric polynomials on the \f$x_i\f$. 
To convert \f$q\f$ from \f$e_i\f$ variables to \f$x_i\f$ variables we use the class  \ref symmp::SymmetricBasis :

	SymmetricBasis<x_poly_t, e_poly_t> SB(2);

The ```2``` signifies that we are using two variables \f$x_1,x_2\f$. Then:

	auto qx=SB(q);
	std::cout << qx;

will set the polynomial ```x_poly_t qx``` to be ```q``` transformed into the \f$x_i\f$ variables (\ref symmp::StandardVariables) and print \f[-1.5x_1^3x_2^5 + -3x_1^4x_2^4 + -1.5x_1^5x_2^3\f]

We can perform the conversion the other way as well: given a polynomial on the \f$x_i\f$ variables such as ```qx``` we can use the object same ```SB``` to transform ``qx`` into a polynomial on the \f$e_i\f$ variables : 

	auto qe=SB(qx);
	std::cout << qe;

which will print \f$-1.5e_1e_2\f$. Observe that ```q==qe``` i.e. the two conversion maps are inverses, as expected.

\subsection halfidem Twisted Chern Basis

We can generate
\f[(R[x_1,...,x_n,y_1,...,y_n]/y_i^2=y_i)^{\Sigma_n}\f]

by the \f$\alpha_i, c_i, \gamma_{s,t}\f$ (see \ref math).

The class \ref symmp::TwistedChernBasis allows us to transform polynomials on \f$x_i,y_i\f$ variables (\ref symmp::HalfIdempotentVariables) into polynomials on the \f$\alpha_i,c_i,\gamma_{s,i}\f$ (\ref symmp::TwistedChernVariables).

Example:

	typedef Poly<int, HalfIdempotentVariables<>> xy_poly_t;
	typedef Poly<int, TwistedChernVariables<>>> chern_poly_t;
	xy_poly_t r;
	r.insert({ 1,0,1,0 }, 2);
	r.insert({ 0,1,0,1 }, 2);
	TwistedChernBasis<xy_poly_t, chern_poly_t> TCB(2);
	std::cout << TCB(r);

This sets ```r``` to be \f$x_1y_1+x_2y_2\f$, transforms it into \f$\gamma_{s,j}\f$ variables and prints the result:

\f[-2\gamma_{1,1}+2\alpha_1 c_1\f]

And indeed:

\f[x_1y_1+x_2y_2=-2\gamma_{1,1}+2\alpha_1 c_1\f]

If we perform the transformation again we get the original polynomial: 

	std::cout << TCB(TCB(poly));

prints \f$x_1y_1+x_2y_2\f$. 

We note that the argument ```2``` in the constructor of ```TCB``` is half the number of variables \f$x_1,x_2,y_1,y_2\f$.


To print the relations amongst \f$\alpha_i,c_i,\gamma_{s,j}\f$ use:

	print_half_idempotent_relations<xy_poly_t, chern_poly_t>(3);
	
The \f$3\f$ here corresponds to the half the number of variables: \f$x_1,x_2,x_3,y_1,y_2,y_3\f$ and can be replaced by any positive integer.

Finally, Demo.cpp contains another function, \ref pontryagin_via_chern. This prints the expressions of the twisted Pontryagin/symplectic classes:

\f[\pi_{s,t}=\kappa_{s,t}=\sum_{1\le i_1< \cdots< i_s\le n\\
1\le j_1< \cdots< j_t\le n\\
i_u\neq j_v}x^2_{i_1}....x^2_{i_s}y_{j_1}\cdots y_{j_t}\f]

in terms of the \f$\alpha_i,c_i,\gamma_{s,t}\f$. 
For example, try running 

	pontryagin_via_chern < xy_poly_t, chern_poly_t>(5);