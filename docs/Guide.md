\mainpage General Information
\tableofcontents
 \section intro Introduction
This is a C++ header only library devoted to computations of symmetric polynomials on variables having relations. You can find the GitHub repository 
<a href="https://github.com/NickG-Math/Symmetric_Polynomials">here</a>. You can also find binaries for Windows and Linux if you want a quick demonstration <a href="https://github.com/NickG-Math/Symmetric_Polynomials/releases">here</a>.


\section req Requirements
 * A C++17 compiler, such as Clang (LLVM), GCC or MSVC. 
 
\section install Installation

* To install simply clone/download the <a href="https://github.com/NickG-Math/Symmetric_Polynomials">repository</a> and include the "source" folder in your path. 

* See the page \ref use for a tutorial on using the library. For a brief explanation on the math behind it, see \ref math.

* The latest version of the code is always tested with the latest stable versions of Clang, GCC (Linux) and MSVC (Windows). 

* You'll need to enable C++17 support in your compiler. For Clang and GCC this is done by the option ```-std=c++17```. 

\section doc Documentation

This documentation is organized in pages as follows:
 
* The pages \ref index, \ref math, \ref use, explain how the program works.

* The pages <a href="namespaces.html">Namespaces</a>, <a href="annotated.html">Classes</a>  and <a href="files.html">Files</a> are automatically generated by doxygen from the source code (and comments in the source code). These offer a much more in depth look into all classes and functions of this project. Note that only public and protected members of classes are documented.

* I recommend starting with \ref math and then testing the code examples in \ref use, before moving to the rest of the pages.

\page math The Math
\tableofcontents
\section sym Symmetric polynomials

Let \f$R=\mathbf Z[x_1,...,x_n]\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ and the fixed points \f$R^{\Sigma_n}\f$ i.e. the symmetric polynomials, form a polynomial algebra on the elementary symmetric polynomials: 
\f[R^{\Sigma_n}=\mathbf Z[\sigma_1,...,\sigma_n]\f] where 
\f[\sigma_k(x_1,...,x_n)=\sum_{1\le i_1< \cdots< i_k\le n}x_{i_1}....x_{i_k}\f]
Furthermore, there is a simple algorithm for writing every symmetric polynomial on the \f$x_i\f$ as a polynomial on the \f$\sigma_i\f$. This library implements that algorithm.


\section hir Symmetric polynomials with 'half idempotent' relations

Let \f$R=\mathbf Z[x_1,...,x_n,y_1,...,y_n]/(y_i^2=y_i)\f$; there is an obvious action on \f$R\f$ by the symmetric group \f$\Sigma_n\f$ permuting the \f$x_i\f$ and \f$y_i\f$ variables separately. A minimal description of the \f$R^{\Sigma_n}\f$ is now more difficult:
\f[R^{\Sigma_n}=\frac{\mathbf Z[\gamma_{s,i}]}{\gamma_{s,i}\gamma_{t,j}=r_{n,s,i,t,j}\gamma_{t,0}\gamma_{s,\min(i+j,n)}+\cdots}\f] where the "twisted Chern classes" are:
\f[\gamma_{s,i}=
\sum_{1\le j_1< \cdots< j_s\le n, 1\le k_1< \cdots< k_i\le n\\ j_u\neq k_v}
x_{j_1}....x_{j_s}y_{k_1}\cdots y_{k_i}\f]
for \f$0\le s\le n\f$ and \f$0\le i\le n-s\f$. The coefficient \f$r_{n,s,i,t,j}\f$ in the relations is given by the binomial:
\f[{\min(i+j+s,n)-t}\choose {j}\f] 
Moreover, the relations require the indices \f$s,i,t,j\f$ to satisfy \f$s\le t\le s+i\f$ and \f$i,j>0\f$.

For convenience we set:
\f[\alpha_i=\gamma_{0,i}=\sigma_i(y_1,...,y_n)\f]
\f[c_s=\gamma_{s,0}=\sigma_s(x_1,...,x_n)\f]
Over \f$\mathbf Q\f$, the \f$\alpha_1^i\f$ can generate all \f$\alpha_i\f$ via:
\f[\alpha_i=\frac{\alpha(\alpha-1)\cdots(\alpha-i+1)}{i!}\f]
however for speed+numerical stability we prefer to use all \f$\alpha_i\f$ and have \f$\mathbf Z\f$ coefficients in our relations.

This library implements an algorithm that can write every element in \f$R^{\Sigma_n}\f$ as a polynomial on the generators \f$\alpha_i,c_i,\gamma_{s,i}\f$ and further produce every relation explicitly. 

The "twisted Pontryagin/symplectic classes" are defined as:
\f[\kappa_{s,i}=\sum_{1\le j_1< \cdots< j_s\le n, 
1\le k_1< \cdots< k_i\le n\\
j_u\neq k_v}x^2_{j_1}....x^2_{j_s}y_{k_1}\cdots y_{k_i}\f]
This library also allows one to write the \f$\kappa_{s,i}\f$ in terms of the \f$\gamma_{s,i}\f$

\page use How to Use
\tableofcontents
\section demo Quick Demonstration

For a quick demonstration you may use the binaries found <a href="https://github.com/NickG-Math/Symmetric_Polynomials/releases">here</a>. These are compiled from Demo.cpp using MSVC (Windows) and GCC (Linux). You can also compile these binaries yourself: For example, on Linux and from within the ```source``` folder use:

    g++ Demo.cpp -std=c++17 -O3 -fopenmp -march=native -o Lin64.out	

Only the ```-std=c++17``` flag is required; the other flags are for optimization.

\section exa Code examples

\subsection namesp Namespaces

Everything in this library is under the namespace \ref symmp (short for Symmetric Polynomials). The code examples that follow will assume we are using this namespace.\n
So start with:

	using symmp;

\subsection mono Polynomials

To specify a polynomial ring such as \f$\mathbf Z[x_1,...,x_n]\f$, \f$|x_i|=1\f$, we use two template parameters:
	
- The scalar type corresponding to the base ring. In our example, \f$\mathbf Z\f$ can be represented by ```int64_t```.
- The "type of variables" used. In our example, we use \ref symmp::StandardVariables "StandardVariables" which specify variables in degree \f$1\f$, with names ```x_i``` (when printed to an output stream) and no relations. We shall explain alternatives in the next few subsections.

The zero element of  \f$\mathbf Z[x_1,...,x_n]\f$ can then be constructed by:

	Poly<int, StandardVariables<>> p;

A nonzero monomial \f$cx_1^{a_1}\cdots x_n^{a_n}\f$ is constructed by providing the exponent vector \f$[a_1,...,a_n]\f$ and the coefficient \f$c\neq 0\f$. \n
For example,

	p=Poly<int, StandardVariables<>>({0,1,4},7);

sets \f$p=7x_2x_3^4\f$. Similarly,

	auto t=Poly<int, StandardVariables<>>({1,1,2},-8);

sets \f$t=-8x_1x_2x_3^2\f$.

Polynomials can be combined via the usual operators ```+,-,*```; they can be raised to a nonnegative integer powers by ```^```.\n
For example:

	p+=t;

sets \f$p=-8x_1x_2x_3^2+7x_2x_3^4\f$ which can be verified by printing \f$p\f$ to the console:

	std::cout << p << "\n";

After that:

	std::cout << (p+(p^2))<< "\n";

will print 

$$-8x_1x_2x_3^2 + 7x_2x_3^4 + 64x_1^2x_2^2x_3^4 - 112x_1x_2^2x_3^6 + 49x_2^2x_3^8$$

which is exactly \f$p+p^2\f$.

@attention	It is the user's responsibility to ensure that:
- the polynomials being combined have the same number of variables.
- the polynomial constructor is never used with \f$0\f$ scalar coefficient (the \f$0\f$ monomial is stored as the empty polynomial)

\subsection symbasis Symmetric Basis

We can substitute \ref symmp::StandardVariables "StandardVariables" with \ref symmp::ElementarySymmetricVariables "ElementarySymmetricVariables" which specify variables with names ```e_i```, degrees \f$|e_i|=i\f$ and no relations. 

Example: The element \f$q=-1.5e_1e_2\f$ of the graded ring \f$\mathbf R[e_1,...,e_n], |e_i|=i\f$, can be defined as: 

	Poly<double, ElementarySymmetricVariables<>> q({ 2,3 }, -1.5);
	
For brevity let us use the following two typedefs:

	typedef Poly<double, StandardVariables<>> x_poly_t;
	typedef Poly<double, ElementarySymmetricVariables<>> e_poly_t;

Now we view \f[\mathbf R[e_1,...,e_n]=\mathbf R[x_1,...,x_n]^{\Sigma_n}\f] with \f$e_i=\sigma_i\f$ being the elementary symmetric polynomials on the \f$x_i\f$. 
To convert \f$q\f$ from \f$e_i\f$ variables to \f$x_i\f$ variables we use the class  \ref symmp::SymmetricBasis "SymmetricBasis" :

	SymmetricBasis<x_poly_t, e_poly_t> SB(2);

The ```2``` signifies that we are using two variables \f$x_1,x_2\f$. Then:

	auto qx=SB(q);
	std::cout << qx;

will set the polynomial ```x_poly_t qx``` to be ```q``` transformed into the \f$x_i\f$ variables (\ref symmp::StandardVariables "StandardVariables") and print \f[-1.5x_1^3x_2^5 -3x_1^4x_2^4 -1.5x_1^5x_2^3\f]

We can perform the conversion the other way as well: given a polynomial on the \f$x_i\f$ variables such as ```qx``` we can use the object same ```SB``` to transform ``qx`` into a polynomial on the \f$e_i\f$ variables : 

	auto qe=SB(qx);
	std::cout << qe;

which will print \f$-1.5e_1e_2\f$. 

@note The two conversion maps are inverses i.e. ```q==qe``` evaluates to \c 1.

\subsection halfidem Twisted Chern Basis

We can generate
\f[(\mathbf Z[x_1,...,x_n,y_1,...,y_n]/y_i^2=y_i)^{\Sigma_n}\f]

by the \f$\alpha_i, c_i, \gamma_{s,t}\f$ (see \ref math).

The class \ref symmp::TwistedChernBasis "TwistedChernBasis" allows us to transform polynomials on \f$x_i,y_i\f$ variables (\ref symmp::HalfIdempotentVariables "HalfIdempotentVariables") into polynomials on the \f$\alpha_i,c_i,\gamma_{s,i}\f$ (\ref symmp::TwistedChernVariables "TwistedChernVariables").

Example:

	typedef Poly<int, HalfIdempotentVariables<>> xy_poly_t;
	typedef Poly<int, TwistedChernVariables<>>> chern_poly_t;
	xy_poly_t r;
	r.insert({ 1,0,1,0 }, 2);
	r.insert({ 0,1,0,1 }, 2);
	TwistedChernBasis<xy_poly_t, chern_poly_t> TCB(2);
	std::cout << TCB(r) << "\n";

This sets ```r``` to be \f$2x_1y_1+2x_2y_2\f$, transforms it into \f$\gamma_{s,j}\f$ variables and prints the result:

\f[-2\gamma_{1,1}+2\alpha_1 c_1\f]

And indeed:

\f[2x_1y_1+2x_2y_2=-2\gamma_{1,1}+2\alpha_1 c_1\f]

If we perform the transformation again we get the original polynomial: 

	std::cout << TCB(TCB(r)) << "\n";

prints \f$2x_1y_1+2x_2y_2\f$. 

@attention The argument ```2``` in the constructor of ```TCB``` is \em half the number of variables \f$x_1,x_2,y_1,y_2\f$.

To print the relations amongst \f$\alpha_i,c_i,\gamma_{s,j}\f$ use:

	print_half_idempotent_relations<xy_poly_t, chern_poly_t>(3);
	
The \f$3\f$ here corresponds to the half the number of variables: \f$x_1,x_2,x_3,y_1,y_2,y_3\f$ and can be replaced by any positive integer.

Finally, Demo.cpp contains another function, \ref pontryagin_via_chern. This prints the expressions of the twisted Pontryagin/symplectic classes:

\f[\pi_{s,t}=\kappa_{s,t}=\sum_{1\le i_1< \cdots< i_s\le n\\
1\le j_1< \cdots< j_t\le n\\
i_u\neq j_v}x^2_{i_1}....x^2_{i_s}y_{j_1}\cdots y_{j_t}\f]

in terms of the \f$\alpha_i,c_i,\gamma_{s,t}\f$. 
For example, try running 

	pontryagin_via_chern < xy_poly_t, chern_poly_t>(5);