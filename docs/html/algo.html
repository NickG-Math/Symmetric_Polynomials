<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Symmetric Polynomials: Select Implementation Details</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Symmetric Polynomials
   &#160;<span id="projectnumber">V0.1</span>
   </div>
   <div id="projectbrief">A C++ library for symmetric polynomials with relations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('algo.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Select Implementation Details </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#smith">Smith Normal Form</a></li>
<li class="level1"><a href="#cob">Change of Basis</a></li>
<li class="level1"><a href="#box">Box product</a></li>
<li class="level1"><a href="#graph">Graphs</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="smith"></a>
Smith Normal Form</h1>
<p>There are multiple ways to compute the Smith Normal Form of a matrix, but since we are mostly interested in the coefficient matrices, we employ the row/column elimination algorithm. To use the algorithm we need to be able to choose a pivot for our matrix each time we want to clear a row and column. We have the freedom to choose it and there are (at least) three ways to do it:</p>
<ul>
<li>Use the first nonzero element as pivot, and if a smaller nonzero element (in absolute value) appears during the elimination then switch to that.</li>
<li>Use the minimum (in absolute value) nonzero elemenent as pivot. If there are multiple choices, pick the first one as we iterate through the matrix.</li>
<li>As above, but instead of picking the first minimum, choose it so that it minimizes a certain norm function.</li>
</ul>
<p>This norm function, called a Markowitz metric, can be for example \(N(i,j)=|\{a_{is}\neq 0: s\}| + |a_{sj}\neq 0:s|\)</p>
<p>One reason we are considering multiple pivoting choices is coefficient explosion: Even if the entries of the matrix are small ( \(\pm 1\)), the entries of the Smith Normal Form (and especially those of the coefficient matrices) can easily overflow if we make the wrong choice of pivot. You can read more about this problem in <a href="https://arxiv.org/abs/math/9406205">Recognizing badly presented Z modules</a>.</p>
<p>Of the three choices above, the first is most likely to result to overflow, but is usually the fastest when it doesn't. The second is a great option for smaller matrices (&lt;1000 rows and columns) while the third excells with very big matrices.</p>
<p>But there is another reason to use the third option, and that's sparse matrices.</p>
<p>When our matrices get large (7000 rows and columns) they are also very sparse (99.9% entries being 0) so we can make huge savings on memory (and potentially computational time) by using a sparse matrix format that only records the nonzero values.</p>
<p>The usage of sparse matrices necessitates great care or performance will suffer: For example, insertions of nonzero elements and random access do not have constant complexity.</p>
<p>As far as the Smith normal form is concerned, to have good performance with sparse matrices we need to minimize fill-in, which is the creation of nonzero elements from adding a row/column to another one. The Markowitz metric described above is used to very roughtly estimate the fill-in that we would get if the given element was used as pivot. There are many other choices as explained <a href="https://arxiv.org/abs/math/9406205">here</a>.</p>
<p>Thus in total we have 4 Smith implementations:</p>
<ul>
<li><code>Mackey::SmithFP</code> using the first nonzero element as pivot. Called in the dense finite coefficient case.</li>
<li><code>Mackey::SmithMP</code> using the minimum (in absolute value) nonzero elemenent as pivot (first instance). Called for dense matrices with at most 1000 rows and columns.</li>
<li><code>Mackey::SmithSP</code> using the instance of the minimum that also minimizes a norm function. Called for dense matrices with above 1000 rows and columns.</li>
<li><code>Mackey::SmithSparse</code> which is the same as <code>Mackey::SmithSP</code> but using sparse matrices. Called for sparse matrices.</li>
</ul>
<h1><a class="anchor" id="cob"></a>
Change of Basis</h1>
<p>If we have bases for modules \(A,B\) then \(A\otimes B\) can be canonically given two lexicographical bases, that we call left and right convenient bases. But if \(A,B\) are the bottom levels of free Mackey functors then they have equivariant bases and the tensor product also gets an equivariant basis, called the canonical one. The left and right convenient bases are used to write the left and right differentials in a simple manner (hence their designation as convenient). The canonical bases are used to transfer. To get the change of basis matrix, we are reduced to computing the permutation \(a^{-1}b\) where \(a,b\) are two permutations of the same set.</p>
<h1><a class="anchor" id="box"></a>
Box product</h1>
<p>Computing the tensor product of Chain complexes breaks down to computing the left and right differentials \(L(x\otimes y)=dx\otimes y\) and \(R(x\otimes y)=(-1)^{|x|}x\otimes dy\) respectively. If we use the convenient bases explained in the previous section, these are just block diagonal matrices with the blocks being the differential from the original chains \(d\). To get \(L,R\) w.r.t. the canonical bases, we need to apply the change of basis matrices. Once we do that the total differential of the tensor product is just \(L+R\). To be more accurate, \(L\) is not a single differential, but rather a sequence of them, one for each summand of the Box product; \((C\otimes D)_n\to (C\otimes D)_{n-1}\) is a map \(C_n\otimes D_0\oplus\cdots \oplus C_0\otimes D_n\to C_0\otimes D_{n-1}\oplus\cdots\oplus C_{n-1}\otimes D_0\). Each summand of this map is computed separately into an \(L\) and an \(R\), and then these are mixed together to form the total differential. The mixing specifies that we start with a block \( L_0\), then place \( R_0\) directly below it, then \(L_1\) adjecent to the right of \( R_0\) etc.</p>
<h1><a class="anchor" id="graph"></a>
Graphs</h1>
<ul>
<li>For weighted graphs we want the shortest path from a given source to all other points. I use a straightforward implementation of Dikjstra's algorithm using std::priority_queue.</li>
<li>For graphs of two colors, we are interested in the paths from the source to all points with the minimum numer of alternating colors (an alternation of colors means switching from division to multiplication and vice-versa). This problem can be easily reduced to finding the shortest path for weighted graphs, by using a sort of "dual" graph where now the nodes are colored and the now monochrome edges between same colored nodes have weight 0, while for different colored nodes we get weight 1. To get the new graph simply duplicate the nodes of the original, color the originals by red and the new ones by blue, and quadruple the edges (so we using all combinations of colored nodes) and set the weights as I just explained. After that, find the red and blue paths starting from a red/blue source and ending to each point, compare them in length and choose the shortest one. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
