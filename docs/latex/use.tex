\hypertarget{use_demo}{}\doxysection{Quick Demonstration}\label{use_demo}
For a quick demonstration you may use the binaries Demo.\+exe or Demo.\+out found \href{https://github.com/NickG-Math/Symmetric_Polynomials/releases}{\texttt{ here}}. These are compiled from \mbox{\hyperlink{Demo_8cpp}{Demo.\+cpp}} using M\+S\+VC and Clang respectively. You can also compile these binaries yourself. For example, on Linux use\+: \begin{DoxyVerb}clang++ source/Demo.cpp -std=c++17 -O3 -march=native -o Demo.out    
\end{DoxyVerb}


You can similarly do this over Windows using M\+S\+VC, producing a .exe file . Make sure to use the {\ttfamily -\/std=c++17} flag (or set the language options in an I\+DE to support C++17).\hypertarget{use_exa}{}\doxysection{Code examples}\label{use_exa}
\hypertarget{use_namesp}{}\doxysubsection{Namespaces}\label{use_namesp}
Everything in this library is under the namespace {\ttfamily \mbox{\hyperlink{namespaceSymmetric__Polynomials}{Symmetric\+\_\+\+Polynomials}}}. For all the following code examples to work, start with \begin{DoxyVerb}using namespace Symmetric_Polynomials;
\end{DoxyVerb}
\hypertarget{use_mono}{}\doxysubsection{Polynomials}\label{use_mono}
A polynomial in multiple variables is specified by two template parameters\+:
\begin{DoxyItemize}
\item {\ttfamily scalar\+\_\+t}\+: the type of coefficients eg {\ttfamily int} or {\ttfamily Rational}
\item {\ttfamily exponent\+\_\+t}\+: the type of variables used eg {\ttfamily Standard\+\_\+\+Variables$<$unsigned char$>$} or {\ttfamily Half\+\_\+\+Idempotent\+\_\+\+Variables$<$unsigned char$>$}. These specify the relations/degrees/names of the variables in the polynomial. For example, {\ttfamily Standard\+\_\+\+Variables$<$unsigned char$>$} specifies variables $x_1,...,x_n$ with degrees $|x_i|=1$ and no relations. On the other hand, {\ttfamily Half\+\_\+\+Idempotent\+\_\+\+Variables$<$unsigned char$>$} specifies variables $x_1,...,x_n,y_1,...,y_n$ with degrees $|x_i|=1, |y_i|=0$ and relations $y_i^2=y_i$. The {\ttfamily unsigned char} is the type for the exponent vectors (see below).
\end{DoxyItemize}

To initialize a polynomial, provide the desired number of variables $n$. For example, if $n=3$\+:

\begin{DoxyVerb}polynomial<int,Standard_Variables<unsigned char>> p(3);
\end{DoxyVerb}


Next, insert monomials $cx_1^{a_1}\cdots x_n^{a_n}$ by providing the exponent vector $[a_1,...,a_n]$ and the coefficient $c$. Eg\+:

\begin{DoxyVerb}p.insert({0,1,4},7);
\end{DoxyVerb}


inserts the monomial $7x_2x_3^4$ in {\ttfamily p}. Note that the exponent vector is of type {\ttfamily Standard\+\_\+\+Variables$<$unsigned char$>$} so $a_i\le 2^8-1$. To allow for bigger $a_i$\textquotesingle{}s, at the cost of more memory, use {\ttfamily unsigned long} in the place of {\ttfamily unsigned char}.

You can also use other coefficients, such as {\ttfamily Rational}, or other types of variables, such as {\ttfamily Half\+\_\+\+Idempotent\+\_\+\+Variables}. For example,

\begin{DoxyVerb}polynomial<Rational,Half_Idempotent_Variables<unsigned char>> p(4);

p.insert({1,2,0,1},Rational(2,3));

p.insert({1,1,1,1},Rational(1,7));
\end{DoxyVerb}


specifies the polynomial $\frac17 x_1x_2y_1y_2+\frac23x_1x_2^2y_2$.

Polynomials can be added, subtracted and multiplied by binary operators {\ttfamily +,-\/,$\ast$}. One can also raise a polynomial to a nonnegative integer power using the binary operator {\ttfamily $^\wedge$}. They can also be printed to an output stream eg by using {\ttfamily std\+::cout $<$$<$ p;}\hypertarget{use_sym}{}\doxysubsection{Symmetric polynomials}\label{use_sym}
The class {\ttfamily Symmetric\+\_\+\+Basis} allows us to transform polynomials on $x_i$ variables (using {\ttfamily Standard\+\_\+\+Variables}) into polynomials on the elementary symmetric polynomials {\ttfamily e\mbox{[}i\mbox{]}} (corresponding to $\sigma_i$). For example\+: \begin{DoxyVerb}Symmetric_Basis<int, Standard_Variables<unsigned char>> SB;

polynomial<int,Standard_Variables<unsigned char>> poly(2);

poly.insert({1,2},2);

poly.insert({2,1},2);

polynomial<int, Elementary_Symmetric_Variables<unsigned char>>  new_poly= SB(poly);

polynomial<int, Standard_Variables<unsigned char>>  new_new_poly= SB(new_poly);

std::cout << poly << "\n";

std::cout<< new_poly << "\n";

std::cout << new_new_poly << "\n";
\end{DoxyVerb}


does the following\+: First it sets {\ttfamily poly} to $2x_1x_2^2+2x_1^2x_2$, transforms into {\ttfamily new\+\_\+poly} which is $2e_1e_2$ and then transforms {\ttfamily new\+\_\+poly} into {\ttfamily new\+\_\+new\+\_\+poly} which is $2x_1x_2^2+2x_1^2x_2$ (i.\+e. the original polynomial) and finally prints the three polynomials. This all means that \$\$2x\+\_\+1x\+\_\+2$^\wedge$2+2x\+\_\+1$^\wedge$2x\+\_\+2=2\textbackslash{}sigma\+\_\+1\textbackslash{}sigma\+\_\+2\$\$\hypertarget{use_halfidem}{}\doxysubsection{Half idempotent relations}\label{use_halfidem}
When we have the \char`\"{}half idempotent relation\char`\"{} i.\+e. variables $x_i,y_i$ with $y_i^2=y_i$ (as specified by {\ttfamily Half\+\_\+\+Idempotent\+\_\+\+Variables}), the generators are $\alpha, c_i, \gamma_{s,t}$ (see \mbox{\hyperlink{math}{The Math}}) or {\ttfamily Idem}, {\ttfamily Chern\mbox{[}i\mbox{]}} and {\ttfamily Twisted\+Chern\mbox{[}s\mbox{]}\mbox{[}t\mbox{]}} respectively as they are used in the program. We order them as $\alpha,c_1,...,c_n, \gamma_{1,1},...,\gamma_{1,n-1},\gamma_{2,1},...,\gamma_{n-1,1}$.

The class {\ttfamily Half\+\_\+\+Idempotent\+\_\+\+Basis} allows us to transform polynomials on $x_i$ variables (using {\ttfamily Standard\+\_\+\+Variables}) into polynomials on the elementary symmetric

The code \begin{DoxyVerb}Half_Idempotent_Basis<Rational,Half_Idempotent_Variables<unsigned char>> HB;

polynomial<Rational,Half_Idempotent_Variables<unsigned char>> poly(4);

poly.insert({ 1,0,1,0 }, 2);

poly.insert({ 0,1,0,1 }, 2);

auto new_poly= HB(poly);

auto new_new_poly= HB(new_poly);

std::cout << poly << "\n";

std::cout << new_poly << "\n";

std::cout << new_new_poly << "\n";
\end{DoxyVerb}


sets {\ttfamily poly} to be $x_1y_1+x_2y_2$, transforms it into {\ttfamily new\+\_\+poly} which is $2\alpha c_1 + -2\gamma_{1,1}$ and then transforms it to {\ttfamily new\+\_\+new\+\_\+poly} in the original variables, which is equal to {\ttfamily poly}, before printing their names. Thus\+:

\$\$x\+\_\+1y\+\_\+1+x\+\_\+2y\+\_\+2=2\textbackslash{}alpha c\+\_\+1-\/2\textbackslash{}gamma\+\_\+\{1,1\}\$\$

To print the relations amongst $\alpha,c_i,\gamma_{s,j}$ simply use\+: \begin{DoxyVerb}print_half_idempotent_relations<Rational, Half_Idempotent_Variables<unsigned char>>(3);
\end{DoxyVerb}


The $3$ here corresponds to the number of variables\+: $x_1,x_2,x_3,y_1,y_2,y_3$ and can be replaced by any positive integer.

There is also a multithreaded version that you can compile yourself, by removing the comment from the \#pragma omp in the definition of {\ttfamily print\+\_\+half\+\_\+idempotent\+\_\+relations}.

Finally, \mbox{\hyperlink{Demo_8cpp}{Demo.\+cpp}} contains another function, {\ttfamily write\+\_\+pontryagin\+\_\+\+C2\+\_\+in\+\_\+terms\+\_\+of\+\_\+\+Chern\+\_\+classes}. This prints the expressions of the twisted Pontryagin/symplectic classes given by \$\$\textbackslash{}pi\+\_\+\{s,t\}=\textbackslash{}kappa\+\_\+\{s,t\}=\textbackslash{}sum\+\_\+\{1\textbackslash{}le i\+\_\+1$<$ \textbackslash{}cdots$<$ i\+\_\+s\textbackslash{}le n\textbackslash{} 1\textbackslash{}le j\+\_\+1$<$ \textbackslash{}cdots$<$ j\+\_\+t\textbackslash{}le n\textbackslash{} i\+\_\+u\textbackslash{}neq j\+\_\+v\}x$^\wedge$2\+\_\+\{i\+\_\+1\}....x$^\wedge$2\+\_\+\{i\+\_\+s\}y\+\_\+\{j\+\_\+1\}\textbackslash{}cdots y\+\_\+\{j\+\_\+t\}\$\$ in terms of the Chern classes $\alpha,c_i,\gamma_{s,t}$. For example, try running write\+\_\+pontryagin\+\_\+\+C2\+\_\+in\+\_\+terms\+\_\+of\+\_\+\+Chern\+\_\+classes(5); 