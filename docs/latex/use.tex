\hypertarget{use_demo}{}\doxysubsection{Quick Demonstration}\label{use_demo}
For a quick demonstration you may use the binaries found \href{https://github.com/NickG-Math/Symmetric_Polynomials/releases}{\texttt{ here}}. These are compiled from \mbox{\hyperlink{Demo_8cpp}{Demo.\+cpp}} using M\+S\+VC (Windows) and G\+CC (Linux). You can also compile these binaries yourself\+: For example, on Linux and from within the {\ttfamily source} folder use\+: \begin{DoxyVerb}g++ Demo.cpp -std=c++17 -O3 -fopenmp -march=native -o Lin64.out 
\end{DoxyVerb}


Only the {\ttfamily -\/std=c++17} flag is required; the other flags are for optimization.\hypertarget{use_exa}{}\doxysubsection{Code examples}\label{use_exa}
\hypertarget{use_namesp}{}\doxysubsubsection{Namespaces}\label{use_namesp}
Everything in this library is under the namespace \mbox{\hyperlink{namespacesymmp}{symmp}} (short for Symmetric Polynomials). The code examples that follow will assume we are using this namespace.~\newline
So start with\+: \begin{DoxyVerb}using symmp;
\end{DoxyVerb}
\hypertarget{use_mono}{}\doxysubsubsection{Polynomials}\label{use_mono}
A polynomial $p$ in the graded ring $\mathbf Z[x_1,...,x_n]$, $|x_i|=1$, can be declared as\+: \begin{DoxyVerb}Poly<int, StandardVariables<>> p;
\end{DoxyVerb}


Here\+:
\begin{DoxyItemize}
\item {\ttfamily int} is the type of the scalar coefficients (i.\+e. elements of the base ring which in this case is $\mathbf Z$), so it can be replaced by {\ttfamily double} and even user-\/defined scalar types.
\item \mbox{\hyperlink{structsymmp_1_1StandardVariables}{symmp\+::\+Standard\+Variables}} specifies variables in degree $1$, with names $x_i$ and no relations. We shall explain alternative variable configurations in the next few subsections.
\end{DoxyItemize}

To insert a monomial $cx_1^{a_1}\cdots x_n^{a_n}$ in $p$ simply provide the exponent vector $[a_1,...,a_n]$ and the coefficient $c$. ~\newline
For example, \begin{DoxyVerb}p.insert({0,1,4},7);
\end{DoxyVerb}


inserts the monomial $7x_2x_3^4$ in $p$. ~\newline
If we further write\+: \begin{DoxyVerb}p.insert({1,1,2},-8);
\end{DoxyVerb}


then $p$ becomes $-8x_1x_2x_3^2+7x_2x_3^4$.~\newline
We can verify that by printing it to the console\+: \begin{DoxyVerb}std::cout << p << "\n";
\end{DoxyVerb}


When inserting monomials in a polynomial, it is the user\textquotesingle{}s responsibility to ensure that\+:
\begin{DoxyItemize}
\item all exponent vectors have the same length (number of variables) and are distinct
\item the scalar coefficients are never $0$
\end{DoxyItemize}

Polynomials of the same type and number of variables can be added, subtracted and multiplied via binary operators {\ttfamily +,-\/,$\ast$} and raised to a nonnegative integer power by {\ttfamily $^\wedge$} For example\+: \begin{DoxyVerb}std::cout << (p+(p^2))<< "\n";
\end{DoxyVerb}


will print

\$\$-\/8x\+\_\+1x\+\_\+2x\+\_\+3$^\wedge$2 + 7x\+\_\+2x\+\_\+3$^\wedge$4 + 64x\+\_\+1$^\wedge$2x\+\_\+2$^\wedge$2x\+\_\+3$^\wedge$4 -\/ 112x\+\_\+1x\+\_\+2$^\wedge$2x\+\_\+3$^\wedge$6 + 49x\+\_\+2$^\wedge$2x\+\_\+3$^\wedge$8\$\$

which is exactly $p+p^2$.\hypertarget{use_symbasis}{}\doxysubsubsection{Symmetric Basis}\label{use_symbasis}
We can substitute \mbox{\hyperlink{structsymmp_1_1StandardVariables}{symmp\+::\+Standard\+Variables}} with \mbox{\hyperlink{structsymmp_1_1ElementarySymmetricVariables}{symmp\+::\+Elementary\+Symmetric\+Variables}} specifying variables with names $e_i$, degrees $|e_i|=i$ and no relations.

Example\+: The element $q=-1.5e_1e_2$ of the graded ring $\mathbf R[e_1,...,e_n], |e_i|=i$, can be defined as\+: \begin{DoxyVerb}Poly<double, ElementarySymmetricVariables<>> q({ 2,3 }, -1.5);
\end{DoxyVerb}


We used the constructor that takes a single monomial in the form of exponent+vector.

For brevity let us use the following two typedefs\+: \begin{DoxyVerb}typedef Poly<double, StandardVariables<>> x_poly_t;
typedef Poly<double, ElementarySymmetricVariables<>> e_poly_t;
\end{DoxyVerb}


Now we view \[\mathbf R[e_1,...,e_n]=\mathbf R[x_1,...,x_n]^{\Sigma_n}\] with $e_i=\sigma_i$ being the elementary symmetric polynomials on the $x_i$. To convert $q$ from $e_i$ variables to $x_i$ variables we use the class \mbox{\hyperlink{classsymmp_1_1SymmetricBasis}{symmp\+::\+Symmetric\+Basis}} \+: \begin{DoxyVerb}SymmetricBasis<x_poly_t, e_poly_t> SB(2);
\end{DoxyVerb}


The {\ttfamily 2} signifies that we are using two variables $x_1,x_2$. Then\+: \begin{DoxyVerb}auto qx=SB(q);
std::cout << qx;
\end{DoxyVerb}


will set the polynomial {\ttfamily x\+\_\+poly\+\_\+t qx} to be {\ttfamily q} transformed into the $x_i$ variables (\mbox{\hyperlink{structsymmp_1_1StandardVariables}{symmp\+::\+Standard\+Variables}}) and print \[-1.5x_1^3x_2^5 + -3x_1^4x_2^4 + -1.5x_1^5x_2^3\]

We can perform the conversion the other way as well\+: given a polynomial on the $x_i$ variables such as {\ttfamily qx} we can use the object same {\ttfamily SB} to transform {\ttfamily qx} into a polynomial on the $e_i$ variables \+: \begin{DoxyVerb}auto qe=SB(qx);
std::cout << qe;
\end{DoxyVerb}


which will print $-1.5e_1e_2$. Observe that {\ttfamily q==qe} i.\+e. the two conversion maps are inverses, as expected.\hypertarget{use_halfidem}{}\doxysubsubsection{Twisted Chern Basis}\label{use_halfidem}
We can generate \[(R[x_1,...,x_n,y_1,...,y_n]/y_i^2=y_i)^{\Sigma_n}\]

by the $\alpha_i, c_i, \gamma_{s,t}$ (see \mbox{\hyperlink{math}{The Math}}).

The class \mbox{\hyperlink{classsymmp_1_1TwistedChernBasis}{symmp\+::\+Twisted\+Chern\+Basis}} allows us to transform polynomials on $x_i,y_i$ variables (\mbox{\hyperlink{structsymmp_1_1HalfIdempotentVariables}{symmp\+::\+Half\+Idempotent\+Variables}}) into polynomials on the $\alpha_i,c_i,\gamma_{s,i}$ (\mbox{\hyperlink{structsymmp_1_1TwistedChernVariables}{symmp\+::\+Twisted\+Chern\+Variables}}).

Example\+: \begin{DoxyVerb}typedef Poly<int, HalfIdempotentVariables<>> xy_poly_t;
typedef Poly<int, TwistedChernVariables<>>> chern_poly_t;
xy_poly_t r;
r.insert({ 1,0,1,0 }, 2);
r.insert({ 0,1,0,1 }, 2);
TwistedChernBasis<xy_poly_t, chern_poly_t> TCB(2);
std::cout << TCB(r);
\end{DoxyVerb}


This sets {\ttfamily r} to be $x_1y_1+x_2y_2$, transforms it into $\gamma_{s,j}$ variables and prints the result\+:

\[-2\gamma_{1,1}+2\alpha_1 c_1\]

And indeed\+:

\[x_1y_1+x_2y_2=-2\gamma_{1,1}+2\alpha_1 c_1\]

If we perform the transformation again we get the original polynomial\+: \begin{DoxyVerb}std::cout << TCB(TCB(poly));
\end{DoxyVerb}


prints $x_1y_1+x_2y_2$.

We note that the argument {\ttfamily 2} in the constructor of {\ttfamily T\+CB} is half the number of variables $x_1,x_2,y_1,y_2$.

To print the relations amongst $\alpha_i,c_i,\gamma_{s,j}$ use\+: \begin{DoxyVerb}print_half_idempotent_relations<xy_poly_t, chern_poly_t>(3);
\end{DoxyVerb}


The $3$ here corresponds to the half the number of variables\+: $x_1,x_2,x_3,y_1,y_2,y_3$ and can be replaced by any positive integer.

Finally, \mbox{\hyperlink{Demo_8cpp}{Demo.\+cpp}} contains another function, \mbox{\hyperlink{Demo_8cpp_a1384cc6cbf29bfb22536612c7e556cef}{pontryagin\+\_\+via\+\_\+chern}}. This prints the expressions of the twisted Pontryagin/symplectic classes\+:

\[\pi_{s,t}=\kappa_{s,t}=\sum_{1\le i_1< \cdots< i_s\le n\\ 1\le j_1< \cdots< j_t\le n\\ i_u\neq j_v}x^2_{i_1}....x^2_{i_s}y_{j_1}\cdots y_{j_t}\]

in terms of the $\alpha_i,c_i,\gamma_{s,t}$. For example, try running \begin{DoxyVerb}pontryagin_via_chern < xy_poly_t, chern_poly_t>(5);
\end{DoxyVerb}
 